use std::fs::File;
use std::io;
use std::io::{BufReader, Read, Seek, SeekFrom};

/// Parses a very specific type of elf, that meets the following constraints
/// 32 bit, little endian, executable, riscv

/// Specification: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format

const MAGIC_NUMBER: [u8; 4] = [0x7f, 0x45, 0x4c, 0x46];

// MemorySegment = (Address, Data)
type MemorySegment = (u32, Vec<u8>);

pub(crate) struct ProgramInfo {
    pub(crate) entry_point: u32,
    pub(crate) code: MemorySegment,
    pub(crate) data: MemorySegment,
}

struct ElfHeaderInfo {
    entry_point: u32,
    program_header_table_offset: u32,
    program_header_entry_size: u32,
    program_entry_count: u32,
}

struct ProgramHeaderInfo {
    data: Vec<u8>,
    virtual_address: u32,
    // true = code_segment, false = data_segment
    code: bool,
}

pub(crate) fn parse_elf(file_path: String) -> ProgramInfo {
    let mut f = BufReader::new(File::open(file_path).unwrap());

    let header_info = parse_elf_header(&mut f);

    let mut code = None;
    let mut data = None;

    for i in 0..header_info.program_entry_count {
        let offset =
            (i * header_info.program_header_entry_size) + header_info.program_header_table_offset;

        if let Some(program_header) = parse_program_header(&mut f, offset) {
            if program_header.code {
                if code != None {
                    panic!("multiple code segments");
                }
                code = Some((program_header.virtual_address, program_header.data));
            } else {
                if data != None {
                    panic!("multiple data segments");
                }
                data = Some((program_header.virtual_address, program_header.data));
            }
        }
    }

    ProgramInfo {
        entry_point: header_info.entry_point,
        code: code.unwrap(),
        data: data.unwrap(),
    }
}

fn parse_elf_header(f: &mut BufReader<File>) -> ElfHeaderInfo {
    // verify_magic_number
    let file_magic_number: [u8; 4] = read_bytes(f).unwrap();
    assert_eq!(file_magic_number, MAGIC_NUMBER);

    // the class must be 32 bits
    assert_eq!(read_bytes(f).unwrap(), [0x01]);

    // ensure little-endian
    assert_eq!(read_bytes(f).unwrap(), [0x01]);

    // ensure system-v abi
    seek(f, 0x07).unwrap();
    assert_eq!(read_bytes(f).unwrap(), [0x00]);

    // skip to offset 0x10 -> e_type
    seek(f, 0x10).unwrap();

    // ensure file type is executable
    assert_eq!(read_bytes(f).unwrap(), [0x02]);

    // seek to machine type
    seek(f, 0x12).unwrap();

    // ensure machine type is riscv (0xF3)
    assert_eq!(read_bytes(f).unwrap(), [0xF3]);

    // seek to entry point
    seek(f, 0x18).unwrap();

    // extract entry point
    let entry_point = u32_le(&read_bytes::<4>(f).unwrap());

    // extract program header table offset
    let program_header_table_offset = u32_le(&read_bytes::<4>(f).unwrap());

    // seek to program header size
    seek(f, 0x2A).unwrap();

    // extract program header size
    let program_header_entry_size = u32_le(&read_bytes::<2>(f).unwrap());

    // extract program header count
    let program_entry_count = u32_le(&read_bytes::<2>(f).unwrap());

    ElfHeaderInfo {
        entry_point,
        program_header_table_offset,
        program_header_entry_size,
        program_entry_count,
    }
}

fn parse_program_header(f: &mut BufReader<File>, offset: u32) -> Option<ProgramHeaderInfo> {
    // seek to offset
    seek(f, offset).unwrap();

    // read type
    let p_type = u32_le(&read_bytes::<4>(f).unwrap());

    // ensure program header is of type LOAD
    if p_type != 1 {
        return None;
    }

    let p_offset = u32_le(&read_bytes::<4>(f).unwrap());
    let virtual_address = u32_le(&read_bytes::<4>(f).unwrap());

    // seek to p_filesz
    seek(f, offset + 0x10).unwrap();

    let p_filesz = u32_le(&read_bytes::<4>(f).unwrap());
    let p_memsz = u32_le(&read_bytes::<4>(f).unwrap());
    let p_flags = u32_le(&read_bytes::<4>(f).unwrap());

    // seek to p_offset
    seek(f, p_offset).unwrap();

    // read header body
    let mut header_body = vec![0_u8; p_filesz as usize];
    f.read_exact(&mut header_body).unwrap();

    // decode flag
    // EXECUTABLE (E) = 1, WRITEABLE (W) = 2, READABLE (R) = 4
    // code = R + E = 4 + 1 = 5
    let is_code = if p_flags == 5 {
        true
    } else if p_flags == 6 {
        false
    } else {
        // neither code nor data panic
        panic!("expected code or data program header body");
    };

    Some(ProgramHeaderInfo {
        data: header_body,
        virtual_address,
        code: is_code,
    })
}

fn read_bytes<const N: usize>(f: &mut BufReader<File>) -> io::Result<[u8; N]> {
    let mut buffer = [0_u8; N];
    f.read_exact(&mut buffer)?;
    Ok(buffer)
}

fn seek(f: &mut BufReader<File>, offset_from_start: u32) -> io::Result<u64> {
    f.seek(SeekFrom::Start(offset_from_start as u64))
}

pub(crate) fn u32_le(data: &[u8]) -> u32 {
    let mut buffer = [0u8; 4];
    let len = data.len().min(4);
    buffer[..len].copy_from_slice(&data[..len]);
    u32::from_le_bytes(buffer)
}
#[cfg(test)]
mod test {
    use crate::elf::{parse_elf_header, parse_program_header};
    use std::fs::File;
    use std::io::BufReader;

    #[test]
    fn test_elf_header_parsing() {
        let mut f = BufReader::new(File::open("test-data/rv32ui-p-add").unwrap());
        let header_info = parse_elf_header(&mut f);
        assert_eq!(header_info.entry_point, 0x80000000);
        assert_eq!(header_info.program_header_table_offset, 0x34);
        assert_eq!(header_info.program_header_entry_size, 32);
        assert_eq!(header_info.program_entry_count, 3);
    }

    #[test]
    fn test_program_header_parsing() {
        let mut f = BufReader::new(File::open("test-data/rv32ui-p-add").unwrap());

        // first header is at offset 52, each header file is 32 bytes
        // hence offset values = 52, 84, 116

        let header_one = parse_program_header(&mut f, 52);
        // should be none because it is not of type load
        assert!(header_one.is_none());

        let header_two = parse_program_header(&mut f, 84).unwrap();
        assert_eq!(header_two.code, true);
        assert_eq!(header_two.virtual_address, 0x80000000);
        assert_eq!(
            header_two.data,
            vec![
                0x6f, 0x00, 0x00, 0x05, 0x73, 0x2f, 0x20, 0x34, 0x93, 0x0f, 0x80, 0x00, 0x63, 0x08,
                0xff, 0x03, 0x93, 0x0f, 0x90, 0x00, 0x63, 0x04, 0xff, 0x03, 0x93, 0x0f, 0xb0, 0x00,
                0x63, 0x00, 0xff, 0x03, 0x13, 0x0f, 0x00, 0x00, 0x63, 0x04, 0x0f, 0x00, 0x67, 0x00,
                0x0f, 0x00, 0x73, 0x2f, 0x20, 0x34, 0x63, 0x54, 0x0f, 0x00, 0x6f, 0x00, 0x40, 0x00,
                0x93, 0xe1, 0x91, 0x53, 0x17, 0x1f, 0x00, 0x00, 0x23, 0x22, 0x3f, 0xfc, 0x17, 0x1f,
                0x00, 0x00, 0x23, 0x20, 0x0f, 0xfc, 0x6f, 0xf0, 0x1f, 0xff, 0x93, 0x00, 0x00, 0x00,
                0x13, 0x01, 0x00, 0x00, 0x93, 0x01, 0x00, 0x00, 0x13, 0x02, 0x00, 0x00, 0x93, 0x02,
                0x00, 0x00, 0x13, 0x03, 0x00, 0x00, 0x93, 0x03, 0x00, 0x00, 0x13, 0x04, 0x00, 0x00,
                0x93, 0x04, 0x00, 0x00, 0x13, 0x05, 0x00, 0x00, 0x93, 0x05, 0x00, 0x00, 0x13, 0x06,
                0x00, 0x00, 0x93, 0x06, 0x00, 0x00, 0x13, 0x07, 0x00, 0x00, 0x93, 0x07, 0x00, 0x00,
                0x13, 0x08, 0x00, 0x00, 0x93, 0x08, 0x00, 0x00, 0x13, 0x09, 0x00, 0x00, 0x93, 0x09,
                0x00, 0x00, 0x13, 0x0a, 0x00, 0x00, 0x93, 0x0a, 0x00, 0x00, 0x13, 0x0b, 0x00, 0x00,
                0x93, 0x0b, 0x00, 0x00, 0x13, 0x0c, 0x00, 0x00, 0x93, 0x0c, 0x00, 0x00, 0x13, 0x0d,
                0x00, 0x00, 0x93, 0x0d, 0x00, 0x00, 0x13, 0x0e, 0x00, 0x00, 0x93, 0x0e, 0x00, 0x00,
                0x13, 0x0f, 0x00, 0x00, 0x93, 0x0f, 0x00, 0x00, 0x73, 0x25, 0x40, 0xf1, 0x63, 0x10,
                0x05, 0x00, 0x97, 0x02, 0x00, 0x00, 0x93, 0x82, 0x02, 0x01, 0x73, 0x90, 0x52, 0x30,
                0x73, 0x50, 0x44, 0x74, 0x97, 0x02, 0x00, 0x00, 0x93, 0x82, 0x02, 0x01, 0x73, 0x90,
                0x52, 0x30, 0x73, 0x50, 0x00, 0x18, 0x97, 0x02, 0x00, 0x00, 0x93, 0x82, 0x02, 0x02,
                0x73, 0x90, 0x52, 0x30, 0xb7, 0x02, 0x00, 0x80, 0x93, 0x82, 0xf2, 0xff, 0x73, 0x90,
                0x02, 0x3b, 0x93, 0x02, 0xf0, 0x01, 0x73, 0x90, 0x02, 0x3a, 0x73, 0x50, 0x40, 0x30,
                0x97, 0x02, 0x00, 0x00, 0x93, 0x82, 0x42, 0x01, 0x73, 0x90, 0x52, 0x30, 0x73, 0x50,
                0x20, 0x30, 0x73, 0x50, 0x30, 0x30, 0x93, 0x01, 0x00, 0x00, 0x97, 0x02, 0x00, 0x00,
                0x93, 0x82, 0x42, 0xed, 0x73, 0x90, 0x52, 0x30, 0x13, 0x05, 0x10, 0x00, 0x13, 0x15,
                0xf5, 0x01, 0x63, 0x4c, 0x05, 0x00, 0x0f, 0x00, 0xf0, 0x0f, 0x93, 0x01, 0x10, 0x00,
                0x93, 0x08, 0xd0, 0x05, 0x13, 0x05, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x93, 0x02,
                0x00, 0x00, 0x63, 0x8a, 0x02, 0x00, 0x73, 0x90, 0x52, 0x10, 0xb7, 0xb2, 0x00, 0x00,
                0x93, 0x82, 0x92, 0x10, 0x73, 0x90, 0x22, 0x30, 0x73, 0x50, 0x00, 0x30, 0x97, 0x02,
                0x00, 0x00, 0x93, 0x82, 0x42, 0x01, 0x73, 0x90, 0x12, 0x34, 0x73, 0x25, 0x40, 0xf1,
                0x73, 0x00, 0x20, 0x30, 0x93, 0x01, 0x20, 0x00, 0x93, 0x05, 0x00, 0x00, 0x13, 0x06,
                0x00, 0x00, 0x33, 0x87, 0xc5, 0x00, 0x93, 0x03, 0x00, 0x00, 0x63, 0x16, 0x77, 0x4c,
                0x93, 0x01, 0x30, 0x00, 0x93, 0x05, 0x10, 0x00, 0x13, 0x06, 0x10, 0x00, 0x33, 0x87,
                0xc5, 0x00, 0x93, 0x03, 0x20, 0x00, 0x63, 0x1a, 0x77, 0x4a, 0x93, 0x01, 0x40, 0x00,
                0x93, 0x05, 0x30, 0x00, 0x13, 0x06, 0x70, 0x00, 0x33, 0x87, 0xc5, 0x00, 0x93, 0x03,
                0xa0, 0x00, 0x63, 0x1e, 0x77, 0x48, 0x93, 0x01, 0x50, 0x00, 0x93, 0x05, 0x00, 0x00,
                0x37, 0x86, 0xff, 0xff, 0x33, 0x87, 0xc5, 0x00, 0xb7, 0x83, 0xff, 0xff, 0x63, 0x12,
                0x77, 0x48, 0x93, 0x01, 0x60, 0x00, 0xb7, 0x05, 0x00, 0x80, 0x13, 0x06, 0x00, 0x00,
                0x33, 0x87, 0xc5, 0x00, 0xb7, 0x03, 0x00, 0x80, 0x63, 0x16, 0x77, 0x46, 0x93, 0x01,
                0x70, 0x00, 0xb7, 0x05, 0x00, 0x80, 0x37, 0x86, 0xff, 0xff, 0x33, 0x87, 0xc5, 0x00,
                0xb7, 0x83, 0xff, 0x7f, 0x63, 0x1a, 0x77, 0x44, 0x93, 0x01, 0x80, 0x00, 0x93, 0x05,
                0x00, 0x00, 0x37, 0x86, 0x00, 0x00, 0x13, 0x06, 0xf6, 0xff, 0x33, 0x87, 0xc5, 0x00,
                0xb7, 0x83, 0x00, 0x00, 0x93, 0x83, 0xf3, 0xff, 0x63, 0x1a, 0x77, 0x42, 0x93, 0x01,
                0x90, 0x00, 0xb7, 0x05, 0x00, 0x80, 0x93, 0x85, 0xf5, 0xff, 0x13, 0x06, 0x00, 0x00,
                0x33, 0x87, 0xc5, 0x00, 0xb7, 0x03, 0x00, 0x80, 0x93, 0x83, 0xf3, 0xff, 0x63, 0x1a,
                0x77, 0x40, 0x93, 0x01, 0xa0, 0x00, 0xb7, 0x05, 0x00, 0x80, 0x93, 0x85, 0xf5, 0xff,
                0x37, 0x86, 0x00, 0x00, 0x13, 0x06, 0xf6, 0xff, 0x33, 0x87, 0xc5, 0x00, 0xb7, 0x83,
                0x00, 0x80, 0x93, 0x83, 0xe3, 0xff, 0x63, 0x18, 0x77, 0x3e, 0x93, 0x01, 0xb0, 0x00,
                0xb7, 0x05, 0x00, 0x80, 0x37, 0x86, 0x00, 0x00, 0x13, 0x06, 0xf6, 0xff, 0x33, 0x87,
                0xc5, 0x00, 0xb7, 0x83, 0x00, 0x80, 0x93, 0x83, 0xf3, 0xff, 0x63, 0x18, 0x77, 0x3c,
                0x93, 0x01, 0xc0, 0x00, 0xb7, 0x05, 0x00, 0x80, 0x93, 0x85, 0xf5, 0xff, 0x37, 0x86,
                0xff, 0xff, 0x33, 0x87, 0xc5, 0x00, 0xb7, 0x83, 0xff, 0x7f, 0x93, 0x83, 0xf3, 0xff,
                0x63, 0x18, 0x77, 0x3a, 0x93, 0x01, 0xd0, 0x00, 0x93, 0x05, 0x00, 0x00, 0x13, 0x06,
                0xf0, 0xff, 0x33, 0x87, 0xc5, 0x00, 0x93, 0x03, 0xf0, 0xff, 0x63, 0x1c, 0x77, 0x38,
                0x93, 0x01, 0xe0, 0x00, 0x93, 0x05, 0xf0, 0xff, 0x13, 0x06, 0x10, 0x00, 0x33, 0x87,
                0xc5, 0x00, 0x93, 0x03, 0x00, 0x00, 0x63, 0x10, 0x77, 0x38, 0x93, 0x01, 0xf0, 0x00,
                0x93, 0x05, 0xf0, 0xff, 0x13, 0x06, 0xf0, 0xff, 0x33, 0x87, 0xc5, 0x00, 0x93, 0x03,
                0xe0, 0xff, 0x63, 0x14, 0x77, 0x36, 0x93, 0x01, 0x00, 0x01, 0x93, 0x05, 0x10, 0x00,
                0x37, 0x06, 0x00, 0x80, 0x13, 0x06, 0xf6, 0xff, 0x33, 0x87, 0xc5, 0x00, 0xb7, 0x03,
                0x00, 0x80, 0x63, 0x16, 0x77, 0x34, 0x93, 0x01, 0x10, 0x01, 0x93, 0x05, 0xd0, 0x00,
                0x13, 0x06, 0xb0, 0x00, 0xb3, 0x85, 0xc5, 0x00, 0x93, 0x03, 0x80, 0x01, 0x63, 0x9a,
                0x75, 0x32, 0x93, 0x01, 0x20, 0x01, 0x93, 0x05, 0xe0, 0x00, 0x13, 0x06, 0xb0, 0x00,
                0x33, 0x86, 0xc5, 0x00, 0x93, 0x03, 0x90, 0x01, 0x63, 0x1e, 0x76, 0x30, 0x93, 0x01,
                0x30, 0x01, 0x93, 0x05, 0xd0, 0x00, 0xb3, 0x85, 0xb5, 0x00, 0x93, 0x03, 0xa0, 0x01,
                0x63, 0x94, 0x75, 0x30, 0x93, 0x01, 0x40, 0x01, 0x13, 0x02, 0x00, 0x00, 0x93, 0x00,
                0xd0, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x03, 0x07, 0x00,
                0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x14, 0x52, 0xfe, 0x93, 0x03,
                0x80, 0x01, 0x63, 0x1e, 0x73, 0x2c, 0x93, 0x01, 0x50, 0x01, 0x13, 0x02, 0x00, 0x00,
                0x93, 0x00, 0xe0, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x00,
                0x00, 0x00, 0x13, 0x03, 0x07, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00,
                0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03, 0x90, 0x01, 0x63, 0x16, 0x73, 0x2a, 0x93, 0x01,
                0x60, 0x01, 0x13, 0x02, 0x00, 0x00, 0x93, 0x00, 0xf0, 0x00, 0x13, 0x01, 0xb0, 0x00,
                0x33, 0x87, 0x20, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x03,
                0x07, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x10, 0x52, 0xfe,
                0x93, 0x03, 0xa0, 0x01, 0x63, 0x1c, 0x73, 0x26, 0x93, 0x01, 0x70, 0x01, 0x13, 0x02,
                0x00, 0x00, 0x93, 0x00, 0xd0, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x33, 0x87, 0x20, 0x00,
                0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x16, 0x52, 0xfe, 0x93, 0x03,
                0x80, 0x01, 0x63, 0x18, 0x77, 0x24, 0x93, 0x01, 0x80, 0x01, 0x13, 0x02, 0x00, 0x00,
                0x93, 0x00, 0xe0, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x33, 0x87,
                0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x14, 0x52, 0xfe,
                0x93, 0x03, 0x90, 0x01, 0x63, 0x12, 0x77, 0x22, 0x93, 0x01, 0x90, 0x01, 0x13, 0x02,
                0x00, 0x00, 0x93, 0x00, 0xf0, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x13, 0x00, 0x00, 0x00,
                0x13, 0x00, 0x00, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02,
                0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03, 0xa0, 0x01, 0x63, 0x1a, 0x77, 0x1e,
                0x93, 0x01, 0xa0, 0x01, 0x13, 0x02, 0x00, 0x00, 0x93, 0x00, 0xd0, 0x00, 0x13, 0x00,
                0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00,
                0x93, 0x02, 0x20, 0x00, 0xe3, 0x14, 0x52, 0xfe, 0x93, 0x03, 0x80, 0x01, 0x63, 0x14,
                0x77, 0x1c, 0x93, 0x01, 0xb0, 0x01, 0x13, 0x02, 0x00, 0x00, 0x93, 0x00, 0xe0, 0x00,
                0x13, 0x00, 0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x33, 0x87,
                0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe,
                0x93, 0x03, 0x90, 0x01, 0x63, 0x1c, 0x77, 0x18, 0x93, 0x01, 0xc0, 0x01, 0x13, 0x02,
                0x00, 0x00, 0x93, 0x00, 0xf0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
                0x13, 0x01, 0xb0, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02,
                0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03, 0xa0, 0x01, 0x63, 0x14, 0x77, 0x16,
                0x93, 0x01, 0xd0, 0x01, 0x13, 0x02, 0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x93, 0x00,
                0xd0, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00,
                0xe3, 0x16, 0x52, 0xfe, 0x93, 0x03, 0x80, 0x01, 0x63, 0x10, 0x77, 0x14, 0x93, 0x01,
                0xe0, 0x01, 0x13, 0x02, 0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x93, 0x00, 0xe0, 0x00,
                0x13, 0x00, 0x00, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02,
                0x20, 0x00, 0xe3, 0x14, 0x52, 0xfe, 0x93, 0x03, 0x90, 0x01, 0x63, 0x1a, 0x77, 0x10,
                0x93, 0x01, 0xf0, 0x01, 0x13, 0x02, 0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x93, 0x00,
                0xf0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x33, 0x87, 0x20, 0x00,
                0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03,
                0xa0, 0x01, 0x63, 0x12, 0x77, 0x0e, 0x93, 0x01, 0x00, 0x02, 0x13, 0x02, 0x00, 0x00,
                0x13, 0x01, 0xb0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x93, 0x00, 0xd0, 0x00, 0x33, 0x87,
                0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x14, 0x52, 0xfe,
                0x93, 0x03, 0x80, 0x01, 0x63, 0x1c, 0x77, 0x0a, 0x93, 0x01, 0x10, 0x02, 0x13, 0x02,
                0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x13, 0x00, 0x00, 0x00, 0x93, 0x00, 0xe0, 0x00,
                0x13, 0x00, 0x00, 0x00, 0x33, 0x87, 0x20, 0x00, 0x13, 0x02, 0x12, 0x00, 0x93, 0x02,
                0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03, 0x90, 0x01, 0x63, 0x14, 0x77, 0x08,
                0x93, 0x01, 0x20, 0x02, 0x13, 0x02, 0x00, 0x00, 0x13, 0x01, 0xb0, 0x00, 0x13, 0x00,
                0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x93, 0x00, 0xf0, 0x00, 0x33, 0x87, 0x20, 0x00,
                0x13, 0x02, 0x12, 0x00, 0x93, 0x02, 0x20, 0x00, 0xe3, 0x12, 0x52, 0xfe, 0x93, 0x03,
                0xa0, 0x01, 0x63, 0x1c, 0x77, 0x04, 0x93, 0x01, 0x30, 0x02, 0x93, 0x00, 0xf0, 0x00,
                0x33, 0x01, 0x10, 0x00, 0x93, 0x03, 0xf0, 0x00, 0x63, 0x12, 0x71, 0x04, 0x93, 0x01,
                0x40, 0x02, 0x93, 0x00, 0x00, 0x02, 0x33, 0x81, 0x00, 0x00, 0x93, 0x03, 0x00, 0x02,
                0x63, 0x18, 0x71, 0x02, 0x93, 0x01, 0x50, 0x02, 0xb3, 0x00, 0x00, 0x00, 0x93, 0x03,
                0x00, 0x00, 0x63, 0x90, 0x70, 0x02, 0x93, 0x01, 0x60, 0x02, 0x93, 0x00, 0x00, 0x01,
                0x13, 0x01, 0xe0, 0x01, 0x33, 0x80, 0x20, 0x00, 0x93, 0x03, 0x00, 0x00, 0x63, 0x14,
                0x70, 0x00, 0x63, 0x10, 0x30, 0x02, 0x0f, 0x00, 0xf0, 0x0f, 0x63, 0x80, 0x01, 0x00,
                0x93, 0x91, 0x11, 0x00, 0x93, 0xe1, 0x11, 0x00, 0x93, 0x08, 0xd0, 0x05, 0x13, 0x85,
                0x01, 0x00, 0x73, 0x00, 0x00, 0x00, 0x0f, 0x00, 0xf0, 0x0f, 0x93, 0x01, 0x10, 0x00,
                0x93, 0x08, 0xd0, 0x05, 0x13, 0x05, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x73, 0x10,
                0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00
            ]
        );

        let header_three = parse_program_header(&mut f, 116).unwrap();
        assert_eq!(header_three.code, false);
        assert_eq!(header_three.virtual_address, 0x80001000);
        assert_eq!(
            header_three.data,
            vec![
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00
            ]
        );
    }
}
